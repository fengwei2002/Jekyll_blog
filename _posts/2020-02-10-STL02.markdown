---
layout: post
title: STL02(类型转换)
tags: [cpp+STL]
date: 2020-02-12 01:29:56
---

Myarray

有参构造
拷贝构造
重载=
重载[]

挖坑待填

```cpp

```

>&&使用:应该传变量的接口用户传值进来,所以就重载一个双引用来解决

void PushBacck(T&& data){
    //判断容器中是否有位置
    if(this->size>=this->capcity){
        return;
    }
    this->addr[this->size]=data;
     this->size++;
}

## 类型转换基本语法

类型转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式

```cpp
//static_cast
void test01(){
    int a=10;
    char c = static_cast<char>(a);
}
```

|类型|功能|对象|
| :-:| :-: |:-:|
| static_cast | 用于内置的数据类型，还有继承关系的指针或者引用 |内置的数据类型，有联系的类指针|
| dynamic_cast | 通常在基类和派生类之间转换时使用|子类转父类的引用和指针|
| const_cast| 取消变量的const性质或者将变量增加const性质，新拿一个变量接收|指针,引用,对象指针|
|reinterpret_cast| 强制类型转换
无关的指针类型都可以进行转换| |

## 案例

static_cast基础数据类型指针不能通过
对象指针转换不能通过
转换具有继承关系的对象指针可以通过
//父类指针转成子类指针(不安全)
//Animal* ani = new Animal;
//Cat* cat = static_cast<Cat*>(ani);
//子类指针转成父类指针(安全)
//Cat* cat = new Cat;
//Animal* ani = static_cast<Animal*>(cat);

static_cast引用也可以转

用于内置的数据类型，还有继承关系的指针或者引用

//static_cast 它能在内置的数据类型间互相转换，对于类只能在有联系的指针类型间进行转换。
//可以在继承体系中把指针转换来、转换去，但是不能转换成继承体系外的一种类型

```cpp
```

dynamic_cast,会有类型检查

不能转换基础数据类型，不能转换非继承关系的指针
大箱子转换小箱子可以进行，子类大于等于父类
小箱子转换为大箱子为不安全行为
原因在于dynamic_cast会做类型安全类型检查

转换具有继承关系的指针或者引用，且只能子类转成父类

而static_cast没有安全检查

```cpp
```

const_cast指针  引用，对象指针

取消变量的const性质或者将变量增加const性质

reinterpret_cast 强制类型转换
1.无关的指针类型都可以进行转换
2.函数指针转换

```cpp
typedef void(FUNC)(int,int);
typedef int(FUNC2)(int ,char*);

FUNC* func1;
FUNC2* func2 =reinterpret_cast<FUNC2*>(func1);
```

## 总结

结论1：程序员必须清楚的知道要转变的变量，转换前是什么类型，转换后是什么类型，
以及转换后有什么后果。



结论2：一般情况下，不建议项目中使用类型转换，避免进行类型转换

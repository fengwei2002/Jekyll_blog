---
layout: post
title: 第二章：向量
tags: [数据结构]
date: 2020-02-15
---
~~date:02-15 02-16~~

## 接口与实现

抽象数据类型

数据结构
vector，list

用户--->汽车，使用说明书，就是数据结构的设计者和使用者的沟通合作方式<---制造者

### 从数组到向量

c/c++中元素与编号一一对应，所以得到编号就能直接访问(lineer array)

向量是数组的抽象和泛化

迭代器访问
不限于基本类型，
参与复杂的算法
有很多接口对于向量内的元素的操作(向量的ADT接口)

### ADT操作实例

```cpp
空向量初始化(从左向右)
insert(0,9)
insert(0,4)
insert(1,5)   //4 5 9
put(1,2)      //修改4，2，9
get(2)        // 9
remove(2)     //删除下标为2且返回那个值
size()
disordered()  //不是0就是无序向量
find(5)       //返回-1表示查找失败
sort()        //排序
search()      //返回下标或者-1，或者前一个，
```

逻辑上和物理上都符合常理要求

### vector模板类的详细实现
```cpp
定义秩
默认初始容量
开始定义模板类
template<typename T>class vector {
    private: Rank size;int  _capaccity; T* _elem
    protected: //内部函数
    public: 
    // 构造函数
    // 析构函数
    // 只读接口
    // 可写接口
    // 遍历接口
}
vector->interface->applications
```

基于复制的构造

分配空间(实际空间是那个的两倍)
有效规模初始化
开始元素的逐一复制


## 可扩充向量

空间自适应  
所以应该采取一些聪明的策略  
开辟一段连续的内存空间  
采用一段连续空间可能出现上溢和下溢(underflow)，元素寥寥无几，利用率极低  
一般应用环境不能准确预测空间需求量  


### 动态空间管理

蝉的哲学，在即将发生上溢时，适当扩大内部空间容量，动态申请一个更大的外壳  
再将东西copy过来，释放原来的空间，将新空间供用户调用  
```cpp
template<typename T>
void Vector<T>::expand{//向量空间不足时扩容
    if(_size<_capcity)return;//尚未满员时，不必扩容
    _capcity=max(_capcity,DEFAULT_CAPCITY);//不低于最小容量
    T* oldElem = _elem;_elem = new T[_capcity<<=1]//容量加倍
    for(int i=0;i<_size;i++){//复制原向量内容
        _elem[i]=oldElem[i];
    }
    delete [] oldElem;//释放原空间
}
```
得益于向量的分装，尽管扩容之后数据地址已经改变，却不出现野指针  


### 那为何要加倍空间呢？

递增式扩容  
追加固定大小的容量  
最坏情况，就是每经过固定次数次后就需要开始扩容一次  
//算数级数  
总体耗时为$O(n^2)$，每次扩容需要$O(n)$的时间  

容量加倍策略

最坏情况，在初始量为一的满向量中连续插入  
//几何级数  
总体耗时为$O(n)$,每次扩容的分摊成本为$O(1)$  
，使用空间的牺牲，换取了时间上的巨大收益  


### 平均分析和分摊分析

概率分布，加权平均  
![34D26A3AC10EA77D875667FD5EE4CB26.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture34D26A3AC10EA77D875667FD5EE4CB26.jpg)


## 无序向量常用算法

template<typename T>class vector{}   
这种方式就可以使数据结构更加方便的被利用   

### 循秩访问  

使用`V.get(r),V.put(r,e)`并不是很方便   
所以要重载`[ ]`这样就可以便捷的使用访问数组的方式来访问向量中的元素  
```cpp
template<typename T>
T & vector<T>::operator[](Rank r)const{
    return _elme[r];
}
```
此后对外的`V[r]`即对应于内部的`V._elme[r]`    
返回值是引用可以做左值或者右值   

### 插入算法 right shift 操作
```cpp
template <typename T>
Rank Vector<T>::insert(Rank r,T const &e){//0(n-r)
    expand();//maybefull,若有需要则扩容，向量可能已经满载
    for(int i=_size;i>r;i--){//自后向前
        _elme[i] = _elme[i-1];//后继元素顺次后移一个单元
        _elme[r] = e;//置入新元素
        _size++;//右移完成后，同时更新容量
        return r;//返回秩
    }
}
```

### 删除算法

区间删除
```cpp
template<typename T>//删除区间[lo,hi]0<=lo<=hi<=size
int vector<T>::remove(Rank lo,Rank hi){//0(n-hi)
    if(lo==hi) return 0;//出于效率考虑，单独处理退化情况
    while (hi< _size) _elem[lo++]=_elem[hi++];//[hi,_size]顺次前移hi-lo位,平移一段空间
    _size=lo; shrink();//更新规模，若有必要则缩容
    return hi-lo;//返回被删除元素的数目
}
```

单元素删除

可以视作区间操作的特例[r]=[r,r+1],所有后缀向前移动  
数据结构更加关注效率，所以不将区间视为单元素的特例而将单元素视为区间的特例
```cpp
template<typename T>//删除向量中秩为r的元素，0<=r<size；
T <vector>::remove(Rank r){//0(n-r)
    T e=_elem[r];//备份被删除的元素
    remove(r,r+1);//调用删除区间的算法
    return e;//返回被删除的元素
}
```

### 查找操作

无序向量需要判等，重载==和!=  
有序向量比较  
逆向扫描  
```cpp
template<typename T>
Rank Vector<T>::find(T const &e,Rank lo,Rank hi)const{
    //在命中多个元素时可返回秩最大者
    while((lo<hi--)&&e!=_elem[hi]);//逆向查找
    return hi;//hi<lo意味着失败；否则hi即命中元素的秩
}
```

### 唯一化算法

网络搜索环境中会用到这种去重工作  
```cpp
template <typename T>//删除重复元素，返回被删除元素数目
int vector<T>::deduplicate(){//繁琐版+错误版
    int oldsize = _size;//记录原规模
    Rank i=1;//从_elem[1]开始
    while (i<size){//自前向后逐一考察各个元素_elem[i]
        (find (_elem[i],0,i)<0)?
         i++//若无雷同则继续向后考查
        : remove(i);//否则删除雷同者
    }
    return oldSize - _size;//向量规模变化量，即删除元素总数
}
```



正确性严格证明

不变性：当前元素v[i]的前缀v[0,i)，各元素彼此互异  
单调性：

find()和remove()累计耗费线性时间，故总体复杂度为$O(n^2)$  
可进一步优化：  
- 依照uniquify()高效版的思路，元素移动次数可降为O(n),但比较次数依然是$O(n^2)$，而且稳定性将被破坏
- v.sort().uniquify():实现最优$O(log_n)$


### 遍历算法 

统一分别实施visit操作  
利用函数指针机制，只读或局部性修改
```cpp
template<typename T>
void Vectorr<T>::traverse(void (*visit)(T&)){
    for(int i=0;i<_size;i++){
        visit(_elem[i]);
    }
}
```

利用函数对象机制，可全局性修改  
```cpp
template<typename T>
template<typename VST>
void Vector<T>::traverse(VST& vist){
    for(int i =0;i<_size;i++){
        visit(_elem[i]);
    }
}

后一种方法的通用性更强

遍历实例

比如，为统一将向量中所有元素分别加一，

- 实现一个可使单个T类型元素加一的类
```cpp
template<typename T>
struct Increase{
    virtual void operator()(T& e){
        e++;
    }
}
template<typename T>
void Increase(Vector<T>& v){
    V.traverse(Increase<T>());
}
```
练习：减一，加倍，求和等遍历功能

## 有序向量

要实现比较操作  
任何一堆相邻元素都顺序  
因此，相邻逆序对数，可用以度量向量的逆序程度
```cpp
for(int i=1;i<size;i++){
    n+=(_elem[i-1] >_elem[i]);
}
 return n;//当且仅当n=0；
```

无序向量转换为有序向量后许多算法就可以进行大幅度的提升


### 唯一化(低效版)

低效算法唯一性，每一区间都保留单个元素即可
```cpp
template<typename T> int vector<T>::uniquify(){
    int oldsize = _size;int i = 0;
    while(i<_size-1)
    (_elem[i]==_elem[i+1])?remove(i+1):i++;
    //若相同则删除后者，否则转移至后一个元素
    return oldsize -_size;
}
```
其复杂度：  
因为要调用remove操作，最坏情况每次都要调用remove操作$O(n^2)$  
和无序向量复杂度一样，所以不推荐


### 唯一化(高效版)

同一元素可作为被删除元素的后继多次前移，尝试将区间一次删除  
一直遍历找到与i不同的元素j，然后将j移动到紧邻i的右侧那个位置，无形中将重复元素忽略
```cpp
template <typename T> int vector<T>::uniquify(){
    Rank i=0,j=0;//各对互异相邻元素的秩
    while(++j<_size>)//逐一扫描，直至末元素
    //跳过雷同者；发现不同元素时，向前移至紧邻前者右侧
    if(_elem[i]!=_elem[j]) _elem[++i]=_elem[j];
    _size = ++i;shrink();//截取尾部多余元素
    return j-i;//向量规模变化量，被删除元素总数
}//注意：通过remove(lo,hi)批量删除，依然不能达到高效率
```
复杂度为$O(n)$只有一次比对操作

### 有序向量:二分查找算法

统一接口

```cpp
template <typename T>//查找算法统一接口，0<=lo<hi<=_size
Rank vector<T>::search(T const &e,Rank lo,Rank hi) const{
    return (rand()%2)?//按照各50%的概率随机选用 0 1
    binsearch(_elem,e,lo,hi)://二分查找算法
    fibsearch(_elem,e,lo,hi);//finbonacci查找算法
}
```

如何处理特殊情况也需要细致约定 

- V.insert(1+V.search(e),e)，保持了有序性和数值区间的稳定性
- search算法返回值是不大于目标的最后一个元素，秩
- 若`负无穷<e<V[lo]` 则返回lo-1
- 若`V[hi-1]<e<正无穷`则返回，hi-1

原理：用轴点将区间分为三个部分  
小于转向左侧区间，大于转向右侧区间，等于median则直接返回；  
不断的缩减问题的规模  

版本A实现

```cpp
template<typename T>//在有序向量区间[lo,hi)内查找元素
static Rank binsearch(T* A,T const& e,Rank lo,Rank hi){
    while(lo<hi){//每步迭代可能要做两次比较判断，有三个分支
        Rank mi =(lo+hi)>>1;//以中点为轴点
        if (e<A[mi]) hi=mi; //深入前半段继续查找，右移一位等于除以2
        else if (A[mi]<e) lo = mi +1;//深入后半段
        else return mi;//在mi处命中
    })
    return -1; //查找失败
}
```

`S.search(8,0,7);`复杂度为$O(log_n)$    
大大优于顺序查找  

### fibsearch(待修改补充)

binsearch比较次数不等，递归深度相等，左侧成本更低  
算法实现
```cpp
template<typename T>
static Rank fibsearch(T* A,T const &e,Rank lo,Rank hi){
    Fib fib(hi-li);
    while(lo<hi){//合法区间
        while(hi-lo<fib.get()) fib.prev();
//通过向前顺序查找，确定形如Fib(k)-1的轴点
        Rank mi = lo +fib.get()-1;
        //按黄金比例分割，相比二分查找优化一点点
        if (e<A[mi]) hi=mi;
        else if(e>A[mi]) lo = mi +1;
        else  return mi;
    }
    return -1;
}
```
### 二分查找(稳定版)

无论向左还是向右，每次迭代只有一次关键码比较   
所有分支只有两个分支`<`或者`>=`  
只有当元素数目`hi-lo=1`时，才会判断是否命中  
版本B
```cpp
template<typename T> static Rank binsearch(T* A,T const& e,Rank lo,Rank hi){
    while (hi-lo>1){
        Rank mi = (lo+hi)>>1;//经过比较后确定深入
        (A[mi]>e)?hi=mi:lo=mi;
    }
    return (e==A[lo])?lo:-1;
}
```
这种算法整体性能更加稳定 

### 遵守语义约定的完整版本

都未严格遵守search()接口语义约定，返回不大于e的最后一个元素  
版本c
```cpp
template<typename T>static Rank binsearch(T* A,T const& e,Rank lo,Rank hi){
    while(hi>lo){ 
        Rank mi=(l0+hi)>>1;
        (A[mi]>e)? hi=mi: lo=mi+1; 
    }//前提是有序向量
    return --lo;
}
```
正确与否？:  严格遵守[0,lo)<=e<[hi,n]

### 有序向量的插值查找

原理与算法

(插值估算)
假设：已知有序向量中各个元素随机分布的规律  
比如：均匀且独立的分布 ，发现元素大体按照线性增长  
所以有
$$\frac{秩}{秩} =\frac{元素的值}{元素的值}$$
因此，通过猜测轴点mi，可以极大的提高收敛速度  
按照总量估计位置，和翻英语字典一样，a在前面找，z在后面找  

最坏情况为$O(n)$，有时候很快，最好情况$O(1)$
平均而言:每经过一次比较，n缩减至  $\sqrt[2]{n}$


## 起泡排序

## 归并排序






---
layout: post
title: 第二章：向量
tags: [数据结构]
date: 2020-02-15
---

## 接口与实现

抽象数据类型

数据结构
vector，list

用户--->汽车，使用说明书，就是数据结构的设计者和使用者的沟通合作方式<---制造者

### 从数组到向量

c/c++中元素与编号一一对应，所以得到编号就能直接访问(lineer array)

向量是数组的抽象和泛化

迭代器访问
不限于基本类型，
参与复杂的算法
有很多接口对于向量内的元素的操作(向量的ADT接口)

### ADT操作实例

```cpp
空向量初始化(从左向右)
insert(0,9)
insert(0,4)
insert(1,5)   //4 5 9
put(1,2)      //修改4，2，9
get(2)        // 9
remove(2)     //删除下标为2且返回那个值
size()
disordered()  //不是0就是无序向量
find(5)       //返回-1表示查找失败
sort()        //排序
search()      //返回下标或者-1，或者前一个，
```

逻辑上和物理上都符合常理要求

### vector模板类的详细实现
```cpp
定义秩
默认初始容量
开始定义模板类
template<typename T>class vector {
    private: Rank size;int  _capaccity; T* _elem
    protected: //内部函数
    public: 
    // 构造函数
    // 析构函数
    // 只读接口
    // 可写接口
    // 遍历接口
}
vector->interface->applications
```

基于复制的构造

分配空间(实际空间是那个的两倍)
有效规模初始化
开始元素的逐一复制


## 可扩充向量

空间自适应  
所以应该采取一些聪明的策略  
开辟一段连续的内存空间  
采用一段连续空间可能出现上溢和下溢(underflow)，元素寥寥无几，利用率极低  
一般应用环境不能准确预测空间需求量  


### 动态空间管理

蝉的哲学，在即将发生上溢时，适当扩大内部空间容量，动态申请一个更大的外壳  
再将东西copy过来，释放原来的空间，将新空间供用户调用  
```cpp
template<typename T>
void Vector<T>::expand{//向量空间不足时扩容
    if(_size<_capcity)return;//尚未满员时，不必扩容
    _capcity=max(_capcity,DEFAULT_CAPCITY);//不低于最小容量
    T* oldElem = _elem;_elem = new T[_capcity<<=1]//容量加倍
    for(int i=0;i<_size;i++){//复制原向量内容
        _elem[i]=oldElem[i];
    }
    delete [] oldElem;//释放原空间
}
```
得益于向量的分装，尽管扩容之后数据地址已经改变，却不出现野指针  


### 那为何要加倍空间呢？

递增式扩容  
追加固定大小的容量  
最坏情况，就是每经过固定次数次后就需要开始扩容一次  
//算数级数  
总体耗时为$O(n^2)$，每次扩容需要$O(n)$的时间  

容量加倍策略

最坏情况，在初始量为一的满向量中连续插入  
//几何级数  
总体耗时为$O(n)$,每次扩容的分摊成本为$O(1)$  
，使用空间的牺牲，换取了时间上的巨大收益  


### 平均分析和分摊分析

概率分布，加权平均  
![34D26A3AC10EA77D875667FD5EE4CB26.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture34D26A3AC10EA77D875667FD5EE4CB26.jpg)


## 无序向量



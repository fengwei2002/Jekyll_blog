---
layout: post
title: 第四章：栈与队列
tags: [数据结构]
date: 2020-02-24
---

线性序列的特例，扮演着基本而重要的角色

## 栈的接口与实现

Stack 一般沿垂直方向画出 堆在一起的椅子就是栈模型，Hanno塔也是这种类型，
只能放在顶部(push)或者取出顶部元素(pop),查询顶部元素(top) 

lost in first out 因为有这种接口，所以一些算法便可以使用这种结构大显身手

因为是一种特例，故可以基于向量或者列表派生出来

```cpp
template<typename T> class Stack public Vector<T>{
    public://size empty 以及其他开放接口均可直接沿用
    void push(T const& e){insert(size(),e);}
    T pop() {return remove(size() - 1);}
    T &top(){return (*this)[size() - 1]; }
};
```

都在向量末尾操作，所以复杂度都是$O(1)$，这也是不在向量头操作的原因

## 逆序输出

输出次序与处理过程颠倒，递归深度和输出长度不易预知

### 典例：进制转换

短除法：
$10->2$ ,将原数除2数的整数部分(商)和余数分开，递归处理，余数部分记录下来既是二进制的表示  
$10->5$ ,分别处理商和余数，然后抄录余数，就完成了转换过程  
计算过程自上而下，输出过程自下而上，计算深度也是未知深度

convert:  
n. 皈依者；改变宗教信仰者  
vt. 使转变；转换…；使…改变信仰  
vi. 转变，变换；皈依；改变信仰  

```cpp
void convert (Stack<char>& S,__int64 n,int base){
    static char digit[] = 
    {'0','1','2','3','4','A','B'}
    while (n>0){ //商为0时退出
        S.push( dight[n % base] );
        n /= base;
    }
}
while( !S.empty()) printf( "%c",S.pop() );pop刚刚好是逆序输出
```

### [典例：括号匹配](https://www.luogu.com.cn/problem/P1739)

1. 分支位置和递归深度都无从得知，使用超级多 if 暴力操作肯定可以解决(对各种特殊情况进行处理) 
2. 消除一对紧邻的括号，不影响全局的判断,那么，如何找到一对，如何简单的持续进行
3. 使用栈的结构，左括号入栈，遇到右括号就弹出栈顶的左括号，最后列表刚好为空即为匹配，中途用完左括号或者最后多出右括号则都是不匹配的

```cpp
bool brackets_match(const char exp[] ,int low,int high){
    Stack<char> S;
    for (int i = low;i < hi;i++){
        if('('==exp[i] ) S.push (exp[i]);
        else if (!S.empty() ) S.pop();//遇到右括号，若栈非空，弹出左括号
        else return false;//遇到右括号时栈已经空掉，必定不匹配
    }
    return S.empty();//最终 匹配
}
```

使用整数计算器也可，并且更加快，计数器反映的即是栈的空间（仅限单类括号

以上思路及算法，可便捷的推广至多种括号并存的情况 ，而不能使用多个计数器实现这种功能  
反例`[(])`而栈就可以  
![352F858B92B1DC394CB70505FB5CCC66.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture352F858B92B1DC394CB70505FB5CCC66.jpg)

甚至，只需约定“括号”的通用格式，而不必事先固定括号的类型和数目

### 典例：栈混洗

![20A3EFF03FDEF4618F43AC2C37C7CFD6.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture20A3EFF03FDEF4618F43AC2C37C7CFD6.jpg)

计数
对于长度为n的序列，可能混洗的情况有几种
卡特兰数数值等于$\frac{(2n!)}{(n+1)!n!}$ n为总数

那么，输入序列的任一排列，如何判断其是否为栈混洗？

任意三个元素能否按照某种次序出现在栈混洗中，与其他元素无关（观察123序列得出

对于任何$1<=i<j<k<=n$ , $[...,k ,... i,...,j >$必非栈混洗  

123 - 312 判断栈混洗的充分必要条件 $O(n^2)$算法

利用栈ABS模拟栈混洗过程，便得到$O(n)$复杂度的算法  
- 每次S.pop()之前，检测S是否已经空，或需要弹出的元素在S中，却非顶元素


### 延时缓冲

表达式求值 













---
layout: post
title: 第七章：二叉搜索树
tags: [数据结构]
date: 2020-03-05
---

***

![images.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/fengwei2002/pictureimages.jpg)

> 标志着我们数据结构进入新的里程碑

## **BST**

巧妙之处在于它的一个子集，平衡二叉搜索树（BBST）

数据项之间，依照各自的关键码彼此区分 `call-by-key` 关键码应该支持 大小比较和相等比对的操作  
为了方便我们将整个 数据集合中的数据项 统一的表示和实现为词条 `entry` 形式

### **词条：**

``` cpp
template<typename K,typename V> struct Entry {
    K key; V value;  //关键码，数值
    Entry(K k = K(),V v = V () ): key(k), value(v) {}; //默认构造函数
    Entry( Entry<k, V> const & e ): key(e.key), value(e.value) {};//克隆构造函数
//比较器，判等器 (从此，不必严格区分词条及其对应的关键码)
    bool operator< (Entry<K, V> const & e ) { return key < e.key; }
    bool operator> (Entry<K, V> const & e ) { return key > e.key; }
    bool operator== (Entry<K, V> const & e ) {return key == e.key;}
    bool operator!= (Entry<K, V> const & e ) {return key != e.key;}
}; //词条的比对转换为关键码的比对操作
```

### **BST**

binary search tree   
为了简便，将节点，词条，关键码 三个名词等同起来，而不加严格的区分

与二叉树的不同：处处满足顺序性；任一节点均不小于/不大于其左/右后代

> 为简化起见。禁止重复词条，但应用时没必要简化

顺序性虽然只是对局部特性的刻画；但由此却可以导出某种全局特征；

* 单调性：BST的中序遍历序列；必然单调非降（树根节点左侧都比树根小，右侧都比树根大；这一性质，也是BST的充要条件；所有单调节点投影构成的序列就是中序遍历序列，只要序列单调变化，则一定是BST

### **BST模板类实现：**

``` cpp
template<typename T> class BST : public BinaryTree<T> {
    public: //以virtual修饰函数，以便派生类重写，二叉树接口仍然可以直接引用
      virtual BinaryNodePosition(T) & search(const T &);//查找
      virtual BinaryNodePosition(T) & insert(const T &);//插入
      virtual bool remove (const T & );//删除
    protected:
      BinaryNodePosition(T) _hot; //命中节点的父亲
      BinaryNodePosition(T) connect34( ) { //3+4重构
          BinaryNodePosition(T), BinaryNodePosition(T), BinaryNodePosition(T),
          BinaryNodePosition(T), BinaryNodePosition(T), BinaryNodePosition(T), BinaryNodePosition(T),
      BinaryNodePosition(T) rotateAt (BinaryNodePosition(T) ); //旋转操作
      }
}
```

## **算法**

### **查找算法**
 第一次从根开始的比较便可以省去一半的数据项；一直与子树的根节点比较；以此规则循环；  

![49ba5ecf853e92c133ad0d502a228f7.jpg](https://raw.githubusercontent.com/fengwei2002/picgotest/master/img/49ba5ecf853e92c133ad0d502a228f7.jpg)

失败时机在一直收缩到最后一个元素时（空树）；

### **search接口**

``` cpp
template<typename T> BinaryNodePosition(T) & BST<T>::search(const T & e)
{return searchIn( _root, e, _hot = NULL ); } //从根节点启动查找 对外的 search接口调用searchIn接口
static BinaryNodePosition(T) & searchIn( //典型的尾递归，可改为迭代版
    BinaryNodePosition(T) & v, //当前（子）树根
    const T & e, //当前关键码
    BinaryNodePosition(T) & hot) {//记忆热点
    if ( !v || ( e == v->data) ) return v; //足以确定失败，成功
    hot = v; //继续递归查找 用 hot 先记下当前（非空）节点，然后再...
    return searchIn(((e < v->data ) ?v->lChild :v->rChild ) e, hot );
}//运行时间正比于返回节点v的深度，不超过树高 O(h) 每运行一次递归下降一层
```

### **接口语义：**

返回的引用值：

* 成功时指向一个关键码为 e 且真实存在的节点
* 失败时；指向最后一次试图转向的空节点 NULL （增加哨兵）
* 无论成功与否：返回值总是等效的指向命中节点；而_hot总是指向命中节点的父亲

### **插入算法：**

借助search接口确定插入位置及方向  返回值_hot 的孩子就是我们该插入的地方 （返回的引用为NULL；刚好被使用）

* 插入算法的实现

``` cpp
template<typename T>BinaryNodePosition(T) BST<T>::insert( const T & e) {
    BinaryNodePosition(T) & x = search(e) ; //查找目标
    if (!x) { //因为禁止雷同元素的存在；所以只在查找失败时进行插入操作
        x = new BinaryNode<T>( e, _hot ); //在x 处创建以 e 为关键码的新节点；此节点以_hot 为父亲
        _size++; updateHeightAbove( x );  //更新全树规模；更新x及其历代祖先的高度
    }
    return x; //无论 e 是否存在于原树中；至此总有 x->data == e
}//验证：对于首个节点插入之类的边界情况；均可正确处置
```

### **删除算法**

相比插入算法更加复杂

* 删除算法的实现

``` cpp
template<typename T> bool BST<T>::remove( const T & e) {
    BinaryNodePosition(T) & x = search( e ); //定位目标节点
    if ( !x ) return false ;
    removeAt( x, _hot ); //
    _size--; //更新规模
    updateHeightAbove( _hot ); //更新 _hot 以及其历代祖先的高度
    return true;
} //删除成功与否，由返回值指示
```

### **删除单分支**  

该节点的某棵子树为空  

``` cpp
template<typename T> static BInaryNodePosition(T) 
removeAt (BinaryNodePosition(T) & x, BinaryNodePosition(T) & hot ) { //删除 x
    BinaryNodePosition(T) w =  x; //实际被摘除的节点，初值同x
    BinaryNodePosition(T) succ = NULL;//实际被删除节点的接替者
    if (! hasLChild( *x ) ) succ = x = x->rChild; //左子树为空
    else if (! hasrChild(*x) ) succ = x = x->lChild; //右子树为空 同时空也正确
    else ( /*...左右子树并存的情况，略微复杂些 */ ) 
    hot = w->parent; //记录实际被删除节点的父亲
    if ( succ ) succ->parent = hot; //将被删除者的接替者与hot相连
    release( w->data ); release( w );//释放被摘除的节点
    return succ; //返回接替者
} //此类情况只需要O(1)的时间
```

### **删除双分支**

化繁为简

转换为情况一

交换要删除节点和他在BST投影中的下一个节点（某个分支的末端）（交换后不是BST）然后删除待删除节点；（恢复了BST的基本构造） _hot指向被删除节点的父亲 最后更新全图信息

![test.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/fengwei2002/picturetest.jpg)

``` cpp
/*...*/
else {
    w = w->succ(); swap( x->data, w->data );
    BinaryNodePosition(T) u = w->parent;
    ( u == x ? u->rChild : u->1chlid ) = succ = w->rChild;
}
/*...*/
```

最坏情况时间复杂度都正比于BST的高度

但如果所有节点构成的树为单链；此时整个树的高度很大；此时静态操作和动态操作的时间都高达O(n) 的复杂度

### **随机生成**

（生成BST的一种方法）可以证明平均高度为$O(log_n)$ 但 213 和231 为同一颗树（且为低树高参与运算）所以平均高度实际用卡特兰数可以推出为$O(\sqrt{n})$

为此我们需要解决这个不理想高度带来的问题

### **理想平衡**

节点数目固定时；兄弟子树高度越接近平衡；全树也倾向于约低（理想二叉树满树）但理想模型基本不会出现；得不偿失

高度渐进的不超过$O(log_n)$；即可称作适度平衡

我们将树高满足适度平衡的树叫做 BBST 平衡二叉搜索树

结构不同的BST中；中序遍历出来的顺序可能一样

所以我们利用这种歧义性 可以实现两个不同树之间的转换

![实例图](https://raw.githubusercontent.com/fengwei2002/picgotest/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200307120214.jpg)

上面两个树就叫做相互等价的BST；上下结构存在调整余地；但左右次序却不能颠倒

### **等价变换**+旋转调整 实现目标 rebalance

## **AVL** 树

最为经典的一种平衡二叉树；AVL是发明者的名字简写

优化BST高度的问题（CBT 除外：完全平衡二叉树）

### **平衡因子：**

对于任意一个节点 v 左子树与右子树的高度差

``` cpp
balFac(v) = height( lc(v) ) - height( rc(v) )
```

当BST所有节点的平衡因子不超过一也不小于负一时；就叫做AVL树；未必是完全二叉树

AVL = 适度平衡

### AVL接口

``` cpp
#define Balanced(x) \ //理想平衡
    ( stature( (x).lChild ) == stature ( (x).rchild ))
#define BalFac(x) \   //平衡因子
    ( stature( (x).lChild ) - stature( (x).rChild ))
#define AvlBalanced(x) \ //AVL平衡条件
    ( ( -2 < BalFac(x) ) && ( BalFac(x) < 2 ))
```

也可以由BST模板类派生AVL的模板类

``` cpp
template <typename T> class AVL : public BST<T> { //由BST派生
    public: //BST::search()等接口，可直接沿用
    BinaryNodePosition(T) insert (const T & ); //插入重写
    bool remove(const T & );//删除重写 
}
```

当用普通搜索实现插入一个节点的动作时；AVL树的许多节点（若干个祖先节点）的平衡状态就会被打乱；而删除操作则至多会引起一个AVL节点的失衡；  

而删除操作并没有因此变得比插入操作简单

实际中插入操作造成的错误其实可以用弥补一个错误的办法全部弥补；删除操作造成的影响则修复起来较为复杂

### 插入：单旋


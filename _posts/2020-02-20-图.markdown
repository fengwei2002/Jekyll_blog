---
layout: post
title: 第六章：图
tags: [数据结构]
date: 2020-03-04
---

***

对数据限定减少，解决的问题规模变大

## 术语

一般用 e(edge) 来表示边的总数  用 v(vertex) 表示节点的总数  
邻接关系 V - V 关联关系 V - e   
此前的数据结构可以看作其特例(树，列表)   

> 自环的边忽略掉不予讨论 

若邻接点 u 和 v 的次序无所谓 则( u , v ) 为无向边 `undirected edge` 
所有边均无向就叫做无向图   
若邻接点 u 和 v 的存在固定次序 则( u , v ) 为有向边 `undirected edge` 
u 称为 tail v 称作 head   
两者混在一起叫做混合图  

> 路径/环路  

在一条通路中不出现重复节点，称作 `simple path` , 否则叫做 `path` . 回到起始点叫做 `cycle(simple)` 
有向无环图 (DAG)  所有的有向边在一起都可以构成一个环路(每个边都经过一遍)叫做欧拉环路，经过节点各一次 且仅有一次 叫做哈密尔顿环路

## **邻接矩阵**

### **概念**

邻接矩阵（主要讨论）   
用正方形 n x n 的每个点表示顶点之间相互邻接关系(是否存在一条边，有为1，没有为0， 有权则改为对应float )的矩阵  则无向图沿对角线对称

关联矩阵   
n个节点(n行) e条边(e列) 矩阵中的任何一个单元表示是否存在关联关系，每一列只有两个1其余都是0

无向图每一条边都被保存了两次，有些多，  
单向边在矩阵中保留一份

### **Graph模板类**

模板类的构建

``` cpp
template <typename Tv,typename Te> class Graph { //顶点类型，边类型
    private:
      void reset(){ //所有顶点，边的辅助信息复位
          for (int i=0;i< n;i++){ //顶点
              status(i) = UNDISCOVERED; dTIME(i) = fTime(i) = -1;
              parent(i) = -1; priority(i) = INT_MAX;
              for (int j=0;j<n;j++) //边
                if (exists(i,j)) status (i,j) = UNDISCOVERED;
          }
      }
    public: /*顶点操作，边操作，图算法: 无论如何实现，接口必须统一*/
} //Graph
```

### **Vertex 模板类**

``` cpp
typedef enum {UNDISCOVERED , DISCOVERED , VISITED } VStatus;
template<typename Tv> struct Vertex { //vertex 顶点
  Tv data; int inDegree, outDegree; // ，记录信息 和出入度数
  /*遍历算法 start*/
  VStatus status; //顶点的状态 三种
  int dTime,fTime;//时间标签 记录顶点被发现和被访问完毕的时刻
  int parent ;    //遍历树中的父节点
  int priority;//priority 优先 在遍历树中的优先级
  /*遍历算法 End*/
  Vertex (Tv const & d)://构建新节点
    data (d) ,inDegree(0) ,outDegree(0), status(UNDISCOVERED),
    dTime(-1),fTime(-1),          parent(-1),
    priority(INT_MAX)   { } //初始化各项
}
```

### **edge 模板类**

``` cpp
typedef enum {UNDETERMINED , TREE , CROSS , FORWARD , BACKWARD }    EStatus;
template <typename Te> struct Edge { //省去严格分装
    Te data;    //数据
    int weight; //权重
    EStatus status;//类型
    Edge (Te const &d ,int w)://构造新边
      data(d) , weight(w) , status(UNDETERMINED) { }
};
```

### **使用 Graph_Matrix 构建图**

`Matrix` : 矩阵  
基于邻接矩阵实现图结构的一种可行方式  
Graph_Matrix

``` cpp
template<typename Tv, typename Te> class Graph_Matrix: public Graph<Tv , Te> {
  private:
    Vector< Vertex<Tv> > V; //顶点集  Vector 读取元素可以在常数时间内完成  
    Vector< Vector< Edge<Te>* >  > E;//边集 因为每个顶点可能与n个顶点相关联，所以要用二维向量构成一个矩形空间（邻接矩阵）
  public:
    /*操作接口，顶点相关，边相关*/
    Graph_Matrix() { n = e = 0 ; } //构造函数
    ~Graph_Matrix() { //析构函数
      for (int j = 0; j < n; j++) 
      for (int k = 0; k < n; k++)
        delete E[j][k];  //清除所有动态申请的边的记录
    }
};
```

### **顶点操作**

``` cpp
Tv & Vertex(int i) { return V[i].data; }
int inDegree(int i){ return V[i].inDegree;}
int outDegree(int i){ return V[i].outDegree;}
Vstatus  & status(int i) {return V[i].status;}
……………………用类似接口直接返回各种状态的引用
```

* 那么对于任意节点 i; 如何枚举其所有的邻接顶点 `neighbor` ?

``` cpp
int nextNbr(int i,int j) { //若已经枚举至邻居j，则转向下一有效邻居
  while ( (j>-1) && !exists (i,--j) ); //逆向顺序查找，O(n) //判断边是否存在  抵达-1时越界终止循环
  return j; //将新发现的邻居返回
}//改用邻接表可提高至 O ( 1+outDegree(i) )
int firstNbr(int i){return nextNbr(i,n); }//首个邻居 ，虽然编号为 n 的节点不存在 
```

### **边操作**

* 判断两个顶点是否存在边

``` cpp
bool exists(int i;int j){  ///判断边(i)(j)是否存在
  return (i>=0) && (n>i) && (j>=0) && (n>j) && E[i][j] != NULL; //短路求值
}
Te & edge (int i,int j) { return E[i][j]->data; } //O(1) 边（i ，j）的数据
Estatus & status (int i,int j){return E[i][j]->status;}//O(1) 边（i ，j）的状态
int & weight (int i,int j) {return E[i][j]->weight;}//O(1)  边（i ，j）的权重
```

* 边插入
  + 将要插入的信息作为模块插入到邻接矩阵对应的单元位置

``` cpp
void insert(Te const& edge, int w, int i, int j){ //插入(i,j,w)
  if (exists(i, j)) return ;  //忽略已经存在的边
  E[i][j] = new Edge<Te>(edge, w); //创建新边 ，完成物理引入
  e++; //更新边计数
  V[i].outDegree++; //更新关联顶点 i 的出度
  V[j].inDegree++;  //更新关联顶点 j 的入度
}
```

* 边删除
  + 将insert操作颠倒过来, 引用指向空

``` cpp
Te remove(int i, int j){ki
  Te eBak = edge(i, j); //做一个备份 
  delete E[i][j]; E[i][j] = NULL;//物理意义上的删除
  e--;
  V[i].outDegree--; //更新关联顶点 i 的出度
  V[j].inDegree--;  //更新关联顶点 j 的入度
  return eBak; //返回被删除边的信息
}
```

### **顶点操作2**

那么如何进行顶点的插入和删除呢
  
因为边的插入和删除邻接矩阵没有空间上的变化，而顶点的变动会引起邻接矩阵大小的变化

顶点插入

``` cpp
int insert(Tv const & vertex) {
  for (int j=0;j<n;j++) E[j].insert(NULL); n++;  ①
  E.insert( Vector< Edge<Te>* > (n ,n ,NULL ) )  ②③
  return V.insert ( Vertex<Tv> (vertex)  );  Ⅵ
}
```

![55979011192C1C19F761DB08F6E2A7E7.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture55979011192C1C19F761DB08F6E2A7E7.jpg)

顶点删除

``` cpp
Tv remove(int i) {  //删除顶点及其关联边，返回该顶点信息
  for (int j=0;j<n;j++) {
    if (exists(i,j)) {   //删除所有出边
      delete E[i][j]; V[j].inDegree--;
    }
  }
  E.remove(i); n--;   //删除所有入边以及第 i 列
  for (int j=0;j<n;j++) {
    if (exists(j,i)) {delete E[j].remove(i); V[j].outDegree--;}
  }
  Tv vBak = Vertex(i); //备份顶点 i 的状态信息
  V.remove(i);  //删除顶点 i
  return vBak;  //返回 i 的信息
}
```

### **优缺点**

* 直观，易于理解和实现
* 适用范围广泛: digraph / network / cyclic / ，尤其适用于稠密图 (dense graph)
* 判断两点是否存在连边：$O(1)$    

   获取顶点的出度和入度：$O(1)$      
   添加删除边后更新度数： $O(1)$  

* 扩展性: 得益于 vector 控制策略；空间溢出可以透明处理

缺点：

> 不相邻的边互不相交的叫做平面图；欧拉公式可以证明：平面图中边的总数不可能超过顶点的总数$O(n)$<<$O(n^2)$, 利用率为 1/n

*  $O(n^2)$ 空间，与边数无关；边数往往会远小于$n^2$

## 广度优先搜索

通过遍历操作，任何一个非线性结构都能转换为线性结构，前者问题变可以用后者方法解决

图中的遍历过程通常目的是针对某一目标，所以叫做搜索

![C2C06A8479FC35379AC4684A29C17EC5.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/image_for_blogC2C06A8479FC35379AC4684A29C17EC5.jpg)

保留原先顶点通往新节点的边，而那些顶点间连有不同的边不予采纳  

像北京环路一样，同一环上的节点连成的边不予考虑，只有不同环上的互相连着的路在广度优先搜索中会被遍历

由于刚才规定的规则，图就变成了这样：

![6BCB46A5695E0110C5CA0F2EF26709CC.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/image_for_blog6BCB46A5695E0110C5CA0F2EF26709CC.jpg)

一幅巨大的无环图，这么看其实是一颗树（刚好包含图中的所有节点）

所以这样的一个遍历过程也就构成了在树中学过的层次遍历，所以图的广度优先搜索就是层次遍历的推广

### **Graph:: BFS**

BFS只是图构建的一个基本框架

``` cpp
template<typename Tv,typename Te>   //顶点类型，边类型
void Graph<Tv，Te>::BFS(int V,int & clock){
  Queue<int> Q; status(v) = DISCOVERED;  Q.enqueue(v); //初始化，依然借助队列完成 当前节点v入队
  while (!Q.empty() ){   //反复的
    int v = Q.dequeue(); //取出队首顶点，并
    dTime(v) = ++clock;  //打上一个时间标签，给出时间进度
    for (int u = firstNbr(v); -1 < u; u = nextNbr(v, u) ) //考察 v 的所有邻居 u ，从第一个邻居开始直至枚举完毕
          /* ……依据u的状态分别处理……*/
    status(v) = VISITED;  //至此，当前节点访问完毕
  }         
} 
```

经过这样的搜索过程，每一个顶点都会由最初的 UNDISCOVERED 变为 DISCOVERED 最终变为 VISITED

### **对于新枚举出来的 u 进行的处理**

``` cpp
while (!Q.empty() ) {  //反复的
  int v = Q.dequeue(); dTime(v) = ++clock;  //取出队首 v 计下时间
  for (int u = firstNbr(v); -1<u; u = nextNbr(v,u) )  //考察每一邻居 u
    if (UNDISCOVERED == status(u) ) {  //UNDISCOVERED状态的 u
      status(u) = DISCOVERED; Q.enqueue(u); //发现该顶点
      status(v, u) = TREE; parent(u) = v; //将 UNDETERMINED 变为 TREE 引入树边，构成 BFS TREE的一个枝条
    }   
    else { //若已经被发现（正在队列中）或者已经访问完毕（已出队列）则
      status(v, u) = CROSS; //将 （v ，u）归类于跨边  忽略父亲边
    }
    status(v) = VISITED; //至此，当前节点访问完毕
}
```

访问一个节点就是把邻居全扔到队列中，然后将自己 DISCOVERED 变为 visited，邻居由 UNDISCOVERED 变为 DISCOVERED 每次是队首节点出队，由此循环

[实例解析搜索过程](http://www.bilibili.com/video/av82410486?p=225&share_medium=android&share_source=copy_link&bbid=PQk6Cz4KOAtoDjYHewd7infoc&ts=1583240625901)

所有的 TREE edge  构成的树就是搜索路径

### **Graph::bfs()**

S 所属的连通域都会被访问 但并不是每幅图都只包含一个连通域（？） 会有一次BFS达不到的连通域

``` cpp
template <typename Tv, typename Te> //顶点类型 边类型
void Graph<Tv, Te>::bfs( int s ) {  //s 为起始顶点
  reset() ; int clock = 0;int v = s;//初始化
  do //逐一排查所有顶点 ，一旦遇到尚未发现的顶点 
    if (UNDISCOVERED == status(v) ) 
        BFS ( v, clock );  //就从该顶点出发启动一次 BFS 
  while ( s != ( v = ( ++v % n) ) );
      //按照序号访问，故可以达到不重不漏
}
```

这样就实现了对多个连通域的统一遍历，每一个连通域通过某个点都进行了一次遍历

### **复杂度分析**

实际运行性能接近于 $O(n + e )$  是算法构建的一个低廉成本

### **最短路径**

顶点 v 的深度（根到节点的唯一通路），所以可以按照顶点的深度指标划分顶点类型   
从起始顶点 s 出发，到顶点 v 许多路径中最短的路径 dist(v, ~~s~~) BFS 也是按照距离来区分被发现的先后顺序  
并且节点与根的通路恰好是 到达顶点的最短路径

## **深度优先搜索**

> DFS 

功能更强大，实现更复杂，因此也成为许多基本算法的框架

## **算法**


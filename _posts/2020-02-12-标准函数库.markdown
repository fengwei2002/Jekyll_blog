---
layout: post
title: 标准函数库
tags: [cpp+STL]
date: 2020-02-17
--- 

>使用侧面目录栏查找更方便哦~
***
**STL基本语法**

创建基础类型容器
```cpp
void print_vector(int v){
    cout<<v;
}
vector<int> v;//容器
//vector<int>::iterator迭代器类型
vector<int>::iterator pBegan = v.began();
vector<int>::iterator pEnd = v.end();//迭代器
//遍历
for_each(pBegan,pEnd,print_vector);//算法
```

创建对象容器
```cpp
vector<person> v;
person p1(10.20);
person p2(30,40);
person p3(50,60);
v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
//遍历
for(vector<person>::iterator it=v.began;it!=v.end();it++){
    cout<<(*it).age;//尖括号放什么取星取出来就是什么
}
```
***

可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是类模板  
对象被插入容器中时，被插入的是对象的一个复制品，许多算法所需要：放入容器的对象所属于的类一般还需要重载`==``<`运算符















## **顺序容器**

容器并非排序的，插入位置与元素的值无关






***
### **vector**

头文件<vector>  
>n. 矢量；带菌者；航线  vt. 用无线电导航  向量

动态数组，元素在内存内连续存放，随机存取任何元素都能在常数时间内完成，在尾部增删元素具有较佳性能(大部分是常数时间)，vector是单口容器，所以在尾
端插入和删除元素效率较高，在指定位置插入，势必会引起数据元素移动，效率较低。


动态增长基本原理：空间不足默认重新申请二倍空间，拷贝原空间值，释放原空间，将元素插入到新空间，会根据不同类型选择不同增长策略。


>vector构造函数

```cpp
vector<T> v; //采用模板实现类实现，默认构造函数 
vector(v.begin(), v.end()); //将 v[begin(), end())区间中的元素拷贝给本身。 
vector(n, elem);//构造函数将 n 个 elem 拷贝给本身。 
vector(const vector &vec);//拷贝构造函数。
//例子 使用第二个构造函数 我们可以... 
int arr[] = {2,3,4,1,9}; 
vector<int> v1(arr, arr + sizeof(arr) / sizeof(int));
```

>vector 常用赋值操作

```cpp
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 
assign(n, elem);//将 n 个 elem 拷贝赋值给本身。 
vector& operator=(const vector &vec);//重载等号操作符 swap(vec);// 将 vec 与本身的元素互换。

//第一个赋值函数，可以这么写： 
int arr[] = { 0, 1, 2, 3, 4 }; 
assign(arr, arr + 5);//使用数组初始化 vector
```

>vector 容量大小操作

```cpp
size();//返回容器中元素的个数 
empty();//判断容器是否为空 
resize(int num);//重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。如果容器变 短，则末尾超出容器长度的元素被删除。 
resize(int num, elem);//重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。如 果容器变短，则末尾超出容器长度的元素被删除。
capacity();//容器的容量 
reserve(int len);//容器预留 len 个元素长度，预留位置不初始化，元素不可访问。
```
- resize 若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的
元素被删除。

- reserve 是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对
象之前，不能引用容器内的元素.

- resize是改变容器的大小，且同时创建对象，因此，调用这个函数之后，就可以引用容
器内的对象了.


>巧用reserve增加程序效率

```cpp
vector<int> v; 
int* p = NULL; 
int count = 0;// 统计 vector 容量增长几次？ 
for (int i = 0; i < 100000;i++){
     v.push_back(i); 
     if (p != &v[0]){
          p = &v[0]; count++; 
        } 
    } 
cout << "count:" << count << endl; //打印出 30
```
向vector插入了10万个元素，vector一共重新分配内存30 次.

```cpp
vector<int> v; 
v.reserve(100000); 
int* p = NULL; 
int count = 0;// 统计 vector 容量增长几次？ 
for (int i = 0; i < 100000;i++){ 
    v.push_back(i); 
    if (p != &v[0]){ 
        p = &v[0]; count++; 
    } 
}
 cout << "count:" << count << endl; 
```
再次向vector插入了10 万个元素，vector一共重新分配内存1次.

所以当我们知道我们存储的元素大概有多少的时候,我们就可以使用reserve方法，来减少vector重新申请内存-拷贝数据-释放旧空间的次数，从而减少程序的运行时间


>vector 数据存取操作

```cpp
at(int idx); //返回索引 idx 所指的数据，如果 idx 越界，抛出 out_of_range 异常。
operator[];//返回索引 idx 所指的数据，越界时，运行直接报错 
front();//返回容器中第一个数据元素 
back();//返回容器中最后一个数据元素
```

>vector 插入和删除操作

```cpp
insert(const_iterator pos, int count,ele);//迭代器指向位置 pos 插入 count个元素ele. 
push_back(ele); //尾部插入元素 ele 
pop_back();//删除最后一个元素 
erase(const_iterator start, const_iterator end);//删除迭代器从 start 到 end 之间的元素 
erase(const_iterator pos);//删除迭代器指向的元素 
clear();//删除容器中所有元素
```








***
### **deque** 

头文件<deque>  "double-ended-queue"
>n. 双端队列；双队列

双向队列，元素在内存内连续存放，随机存取任何元素都能在常数时间内完成(但次于vector)，在两端增删元素具有较佳性能(大部分是常数时间),vector是单向开口的连续性空间,deque 则是一种双向开口的连续性空间，所谓双向开口，
意思是可以在头尾两端分别做元素的插入和删除操作，vector当然也可以在头尾两端进行插入和删除操作，但是头部插入和删除操作效率奇差，无法被接受。

>deque和vector的最大差异？

- 在于deque允许常数时间内对头端进行元素插入和删除操作。
- 在于deque没有容量的概念，因为它是动态的以分段的连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“因旧空间不足而重新分配一块更大的空间，然后再复制元素，释放空间”这样的操作不会发生在deque身上，也因此deque没有必要提供所谓的空间保留功能。
- 双端插入和删除元素效率较高.
- 指定位置插入也会导致数据元素移动,降低效率.
- 可随机存取,效率高.

> deque 构造函数

```cpp
deque<T> deqT;//默认构造形式 
deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。 
deque(n, elem);//构造函数将 n 个 elem 拷贝给本身。 
deque(const deque &deq);//拷贝构造函数。
```

>deque 赋值操作

```cpp
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。 
assign(n, elem);//将 n 个 elem 拷贝赋值给本身。 
deque& operator=(const deque &deq); //重载等号操作符 
swap(deq);// 将 deq 与本身的元素互换
```

> deque 大小操作
```cpp
deque.size();//返回容器中元素的个数 
deque.empty();//判断容器是否为空 
deque.resize(num);//重新指定容器的长度为 num,若容器变长，则以默认值填充新位置。如果容器 变短，则末尾超出容器长度的元素被删除。 
deque.resize(num, elem); //重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置,如 果容器变短，则末尾超出容器长度的元素被删除。
```
> deque 双端插入和删除操作

```cpp
push_back(elem);//在容器尾部添加一个数据 
push_front(elem);//在容器头部插入一个数据 
pop_back();//删除容器最后一个数据 
pop_front();//删除容器第一个数据
```

>deque 数据存取


```cpp
at(idx);//返回索引 idx 所指的数据，如果 idx 越界，抛出 out_of_range。 operator[];//返回索引 idx 所指的数据，如果 idx 越界，不抛出异常，直接出错。 
front();//返回第一个数据。 
back();//返回最后一个数据
```
>deque 插入操作

```cpp
insert(pos,elem);//在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。 
insert(pos,n,elem);//在 pos 位置插入 n 个 elem 数据，无返回值。 insert(pos,beg,end);//在 pos 位置插入[beg,end)区间的数据，无返回值。
```

deque是分段连续的内存空间，通过中控器维持一种连续内存空间的状态，
其实现复杂性要大于vector queue stack等容器，其迭代器的实现也更加复杂，在需要对deque容器元素进行排序的时候，建议先将 deque容器中数据数据元素拷贝到 vector容器中，对vector进行排序，然后再将排序完成的数据拷贝回 deque容器。

>deque删除操作

```cpp
clear();//移除容器的所有数据 
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 
erase(pos);//删除 pos 位置的数据，返回下一个数据的位置。
```




















***
### **list双向链表**

头文件<list>

双向链表，元素在空间内不是连续存放的，在任何位置增删元素都能在常数时间内完成，调用元素时要事先知道位置，不支持随机存取

### 顺序容器常用成员函数

- front: 第一个元素的引用
- back: 最后一个元素的引用
- push_back: 在容器末尾增加新的元素
- pop_back: 删除容器末尾的元素
- earse: 删除迭代器所指向的元素(迭代器可能失效),或删除一个区间，返回被删除元素后面的那个元素的迭代器























## 关联容器

- 元素是排序的
- 插入任何元素都按照相应的排序规则来确定其位置
- 在查找时具有较好的性能
- 通常以平衡二叉树方式实现，插入和检索时间都很快

### set/multiset

头文件<set>

set即集合，set中不允许有相同的元素，multiset中允许存在相同的元素

### map/multimap

头文件<map>

map中存放的元素有且仅有两个成员变量，一个名为first另一个名为second，map根据first的值对元素进行从小到大的排序，并可以快速的
根据first来检索元素，multimap里面允许有相同first值的元素



















## 容器适配器

### stack

头文件<stack>  

栈，后进先出，检索和修改的项只能是最近插入栈顶的项

### queue

头文件<queue>

队列，插入只可以从尾部进行，检索和修改只允许从头部进行，先进先出

### priority_queue

头文件<queue>

优先级队列，最高优先级元素总是第一个出列

### 顺序容器和关联容器共有的成员函数

- began 返回第一个元素的迭代器
- rbegan 返回最后一个元素的迭代器
- end 最后一个元素后面的位置
- rend 第一个元素前面的位置
- erase 从容器中删除一个或几个元素
- clear 从容器中删除所有元素














## 迭代器

- 用于指向顺序容器和关联容器中的元素
- 用法和指针类似
- 有const和非const两种
- 通过迭代器可以读取他所指向的元素
- 通过非const迭代器还能修改其指向的元素
迭代器实际上是一个类，这个类封装一个指针  

定义一个容器类迭代器的方法可以是

`容器类名::iterator 变量名`

>n. 迭代器；迭代程序

或
`容器类名::const_iterator 变量名`

访问一个迭代器所指向的元素，`*迭代器变量名`

# 算法

通过有限步骤，解决问题

函数模板





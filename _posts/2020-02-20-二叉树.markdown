---
layout: post
title: 第五章 二叉树
tags: [数据结构]
date: 2020-02-26
---
## 树

Tree = $List^2$

应用 
层次关系的表示，文件管理系统，

### 树基本结构

每一个节点都叫做 顶点 vertex 指定任一节点 r 属于 V作为根后 ，T即称作有根树(rooted tree) subtree

parent child sibling(兄弟) degree

任何一个树的边数和其顶点的规模同阶

若将同一节点的孩子们编号，则称作有序树(ordered tree)

### 路径(path)加环路

依次相连的k+1的节点，构成一条路径，//通路  
路径长度就是参与构成其的边数     //早期文献以节点数为长度  

环路，loop 节点构成环

节点之间均有路径，称作连通图(connected)，不含环路，称作无环图(acyclic)

五环连通图，极小连通图，极大无环图

故：任一节点v与艮之间存在唯一路径
$$path(v,r)=path(v)$$
节点拥有的指标便是这条通路的长度 通过指标可以将节点化为几类  

### 深度加层次
```cpp
path from root to  v = path v  
subtree rotted at v = subtree v
```
节点具有的那个指标也叫做树的深度(depth)  
path(V)上的节点，均为v的祖先(ancestor) v 是他们的后代(descendent)//proper  
前驱的唯一性仍然保持，后继的唯一性未必，所以树也叫做半线性结构  
那么图就叫做非线性结构  

- 根节点深度为0 ，公共祖先 ，
- 没有后代的节点称作叶子
- 所有叶子最大值的深度就叫做树的高度
- 子树也具有高度，全树的高度
- 特别的，空树的高度取做-1
- $depth(v) + height(v) <= heigth(T)$

![DDF4E96BC16EEC8F010C65B5E300B496.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/pictureDDF4E96BC16EEC8F010C65B5E300B496.jpg)

## 二叉树

### 树的接口设计

![A1A669469932A264ECD45FB0121803C7.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/pictureA1A669469932A264ECD45FB0121803C7.jpg)

将顶点的children组成一个新的序列，度数就是孩子的数目，可以加快查找孩子的速度

对于同一个节点：保留parent数据集和child数据集，这样的实现方法两全其美

child数据集的长度相差较大

每个节点均设置两个引用，纵first_child，横next_sibling父母关注长子，然后其余互相照顾

对于任意一个节点，只保留长子的一个引用，长子通过横向引用确认其他节点（长子兄弟法）（最佳）

### 二叉树概述

节点数不超过2的树，称作二叉树

同一节点的孩子和子树，均以左右区分，(左在前)，二叉树足以描述所有的树

深度为k的树，最多$2^k$个节点,最多时叫做满树(full binary_tree)，长宽的速度非常快，长高的速度非常慢

### 真二叉树

每个节点的粗度都是偶数，0 or 2 虚拟模拟

![75E71F923C483C9403256E58E91CFED6.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture75E71F923C483C9403256E58E91CFED6.jpg)

### 用二叉树描述多叉树

有根且有序的树都能通过二叉树表示和实现（长子兄弟法）

![3A2536F3E5918997190B0AF48297710E.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture3A2536F3E5918997190B0AF48297710E.jpg)


## 二叉树的实现

二叉树的基本单位是二叉树的节点叫做 BinaryNode 模板类

- 核心：data ，
- 引用：parent ，1child ，2child ，
- 属性：height，npl，color 

```cpp
#define BinaryNodePosition(T)  BinaryNode<T>* //节点位置
template<typename T> struct BinaryNode {
    BinaryNodePosition(T) parent,1child,2child; //父亲 孩子
    T data; int height ;int size() ;//数据区，高度，和子树规模
    BinaryNodePosition(T) insert_as_left_child(T const & );//插入新节点
    BinaryNodePosition(T) insert_as_right_child(T const & );
    BinaryNodePosition(T) success( ); //（中序遍历意义下）当前节点的直接后继
    template<typename VST> void travLevel (VST &);//子树层次遍历
    template<typename VST> void travPre(VST &);   //子树先序遍历
    template<typename VST> void travIn(VST &);    //子树中序遍历
    template<typename VST> void travPost(VST &);  //子树后序遍历 ,提供四种基本遍历的接口
}
```
### BinaryNode接口实现

```cpp
template <typename T> BinaryNodePosition(T) BinaryNode<T>::insert_as_left_child(T const & e){
    return 1child = new BinaryNode ( e ,this );//构建新节点 data 域为e 父节点为 this 返回值为 position 所以直接将结果赋值给 1child
}
```
Right_child 完全对称

size接口:
```cpp
template <typename T>
int BinaryNode<T>::size(){
    int s = 1;
    if (1child) s += 1child->size;
    if ()
}
```






































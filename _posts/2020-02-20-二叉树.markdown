---
layout: post
title: 第五章 二叉树
tags: [数据结构]
date: 2020-02-28
---
## **树**

Tree = $List^2$

应用 
层次关系的表示，文件管理系统，

### **树基本结构**

每一个节点都叫做 顶点 vertex 指定任一节点 r 属于 V作为根后 ，T即称作有根树(rooted tree) subtree

parent child sibling(兄弟) degree

任何一个树的边数和其顶点的规模同阶

若将同一节点的孩子们编号，则称作有序树(ordered tree)

### **路径(path)加环路**

依次相连的k+1的节点，构成一条路径，//通路  
路径长度就是参与构成其的边数     //早期文献以节点数为长度  

环路，loop 节点构成环

节点之间均有路径，称作连通图(connected)，不含环路，称作无环图(acyclic)

五环连通图，极小连通图，极大无环图

故：任一节点v与艮之间存在唯一路径
$$path(v,r)=path(v)$$
节点拥有的指标便是这条通路的长度 通过指标可以将节点化为几类  

### **深度加层次**
```cpp
path from root to  v = path v  
subtree rotted at v = subtree v
```
节点具有的那个指标也叫做树的深度(depth)  
path(V)上的节点，均为v的祖先(ancestor) v 是他们的后代(descendent)//proper  
前驱的唯一性仍然保持，后继的唯一性未必，所以树也叫做半线性结构  
那么图就叫做非线性结构  

- 根节点深度为0 ，公共祖先 ，
- 没有后代的节点称作叶子
- 所有叶子最大值的深度就叫做树的高度
- 子树也具有高度，全树的高度
- 特别的，空树的高度取做-1
- $depth(v) + height(v) <= heigth(T)$

![DDF4E96BC16EEC8F010C65B5E300B496.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/pictureDDF4E96BC16EEC8F010C65B5E300B496.jpg)

## **二叉树**


### **树的接口设计**

![A1A669469932A264ECD45FB0121803C7.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/pictureA1A669469932A264ECD45FB0121803C7.jpg)

将顶点的children组成一个新的序列，度数就是孩子的数目，可以加快查找孩子的速度

对于同一个节点：保留parent数据集和child数据集，这样的实现方法两全其美

child数据集的长度相差较大

每个节点均设置两个引用，纵first_child，横next_sibling父母关注长子，然后其余互相照顾

对于任意一个节点，只保留长子的一个引用，长子通过横向引用确认其他节点（长子兄弟法）（最佳）

### **二叉树概述**

节点数不超过2的树，称作二叉树

同一节点的孩子和子树，均以左右区分，(左在前)，二叉树足以描述所有的树

深度为k的树，最多$2^k$个节点,最多时叫做满树(full binary_tree)，长宽的速度非常快，长高的速度非常慢

### **真二叉树**

每个节点的粗度都是偶数，0 or 2 虚拟模拟

![75E71F923C483C9403256E58E91CFED6.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture75E71F923C483C9403256E58E91CFED6.jpg)

### **用二叉树描述多叉树**

有根且有序的树都能通过二叉树表示和实现（长子兄弟法）

![3A2536F3E5918997190B0AF48297710E.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture3A2536F3E5918997190B0AF48297710E.jpg)


## **二叉树的实现**
二叉树的基本单位是二叉树的节点叫做 BinaryNode 模板类

- 核心：data ，
- 引用：parent ，1child ，2child ，
- 属性：height，npl，color 

```cpp
#define BinaryNodePosition(T)  BinaryNode<T>* //节点位置
template<typename T> struct BinaryNode {
    BinaryNodePosition(T) parent,1child,2child; //父亲 孩子
    T data; int height ;int size() ;//数据区，高度，和子树规模
    BinaryNodePosition(T) insert_as_left_child(T const & );//插入新节点
    BinaryNodePosition(T) insert_as_right_child(T const & );
    BinaryNodePosition(T) success( ); //（中序遍历意义下）当前节点的直接后继
    template<typename VST> void travLevel (VST &);//子树层次遍历
    template<typename VST> void travPre(VST &);   //子树先序遍历
    template<typename VST> void travIn(VST &);    //子树中序遍历
    template<typename VST> void travPost(VST &);  //子树后序遍历 ,提供四种基本遍历的接口
}
```
### **BinaryNode接口实现**

```cpp
template <typename T> BinaryNodePosition(T) BinaryNode<T>::insert_as_left_child(T const & e){
    return 1child = new BinaryNode ( e ,this );//构建新节点 data 域为e 父节点为 this 返回值为 position 所以直接将结果赋值给 1child
}
```
Right_child 完全对称

size接口:线性时间
```cpp
template <typename T>
int BinaryNode<T>::size(){//递归实现
    int s = 1; //本身
    if (1child) s += 1child->size();
    if (rchild) s += rchild->size();
    return s; //两项合计加上当前节点本身，递归则得出当前的 size()
}
```

### **BinaryTree 模板类**

```cpp
template <typename T> class BinaryTree{
    protected:
      int _size; //规模
      BinaryNodePosition(T) _root; //根节点
      virtual int updateHeight(BinaryNodePosition(T) x);  //更新节点x的高度
      void updateHeightAbove(BinaryNodePosition(T) x);    //更新x及其祖先的高度
    public:
      int size() const {return _size;}//规模
      bool empty() const {return !-root}//判空
      BinaryNodePosition(T) root() const {return _root} //树根
      //子树接口 ，删除和分离接口 ，遍历接口 
}
```
### **高度更新**

定义：对于节点 x ，在以它为根的叶节点最长距离，无子节点 h=0 ，root 的高度为 -1  
左右 child 的高度最大再加一

```cpp
#define stature(p) ( (p) ? (P)->height : -1 )//将特殊情况统一起来更加方便 且不影响到算法的正确性
template<typename T>
int BinaryTree<T>::updateHeight( BinaryNodePosition(T) x){
    return x->height = 1 + max (stature( x->1child ),stature (x->2child) );
}//采用常规二叉树规则，O(1) 

template<typename T> void BinaryTree<T>::updateHeightAbove( BinaryNodePosition(T) x){//更新x及其历代祖先的高度
    while(x) {updateHeight(x); x = x->parent; } //可优化，一旦高度未变即可终止
}//O(n =depth)              从 x 开始更新整颗树的高度
```

### **节点插入**

```cpp
template<typename T> BinaryNodePosition(T) BinaryTree<T>::insert_as_right_child (BinaryNodePosition(T) x ,T const & e){//insertaslc对称
_size++; x->insertAsRC(e); //新节点创建时就完成自下而上的连接，调用同名接口完成自上而下的连接
updateHeightAbove(X); //更新 x 及其祖先的高度
return x->2child; //返回右节点（执行插入的位置）
}
```

## **二叉树的相关算法**

将 半线性结构 -> 之前研究完整的线性结构

遍历：按照某种次序，每一个节点都恰好被访问一次，只要根节点和左右子节点可以确定一种顺序，那么便可以执行下去
先序中序后序就是根据 根节点的先后来区分的    

![89B2747A227ED7347DECFEDC58C24E05.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture89B2747A227ED7347DECFEDC58C24E05.jpg)

层次遍历和广度遍历以后会有讨论

### **先序遍历**

```traverse: 遍历```

递归实现

```cpp
template<typename T ,typename VST> 
void traverse(BinaryNodePosition(T) x,VST & visit){
    if (!x) return ; //递归基
    visit (x->data);
    traverse(x->1child,vist); traverse(x->2child,visit);
}  //复杂度为O(n)
```
$递归->迭代$

迭代1实现,引入一个栈

```cpp
template<typename T,typename VST>
void travPre_I(BinaryNodePosition(T) x,VST & visit){
    Stack <BinaryNodePosition(T)> S; //辅助栈
    if (x) S.push(x); //根节点入栈
    while (!S.empty() ){ //在非空前反复访问
        x = S.pop(); visit (x->data); //弹出栈顶 并同时访问当前节点，当x节点左右都有时没有推入 弹两次  
        if (HasRChild( *x) ) S.push (  x->2child); //存在有孩子就推入栈中，右孩子先入后出
        if (HasLChild( *x) ) S.push (  x->1child); //存在左孩子也推入栈中，左孩子后入先出
    }
}               妙啊
```

![AC70CB6322098BC7C6204D083FB726E4.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/pictureAC70CB6322098BC7C6204D083FB726E4.jpg)

但这种不易于推广至中序遍历

迭代2 思路

![15604BB676F81A604F0C13C81599E1ED.jpg](https://raw.githubusercontent.com/fengwei2002/picture/master/picture15604BB676F81A604F0C13C81599E1ED.jpg)

根->左->左->右(没有左侧链时)->左->左

先遍历最左侧的一列树，然后遍历每一个左节点对应的右节点

实现：
```cpp
template<typename T,typename VST>
static void visitAlongLeftBranch(
    BinaryNodePosition(T) x,
    VST & visit,
    Stack <BinaryNodePosition(T)> &S) //后进先出的次序
{
    while (x) {
        visit (x->data);
        S.push(x->2child); //右孩子入栈，将来逆序出栈，第一个为根节点的右孩子
        x = x->1child;     //沿着左链下滑
    }
}
```

[主算法](http://www.bilibili.com/video/av82410486?p=195&share_medium=android&share_source=copy_link&bbid=PQk6Cz4KOAtoDjYHewd7infoc&ts=1582945732432
)
```cpp
template<typename T,typename VST>
void travPre_II(BinaryNodePosition(T) x ,VST & visit){
    Stack <BinaryNodePosition(T)> S;
    while (true ) {
        visitAlongLeftBranch (x , visit , S );//传入大家公用的栈
        if (S.empty() ) break; //栈空退出
        x = S.pop(); //弹出下一子树的根
    }
}
```







































---
layout: post
title: STL DAY01
categories: [笔记]
tags: [C++ STL笔记]
date: 2020-02-09 01:29:56
---
## 函数模板

### 函数模板的基本语法

例如我们使用不同参数类型的swap 函数时，逻辑相同，但需要相同逻辑写多次，这样就会出现代码不能复用，增加维护成本，等问题

这时人们就引入了模板技术 ，也就是编写函数代码时可以忽略参数类型，一个函数接口实现多种不同的操作

```cpp
template<class T>//template<typename T>
void MySwap(T& a,T& b){
    T temp=a;
    a=b;
    b=temp;
}
```

为了让编译器区分普通函数还是模板函数,在函数前面加上`template(模板)``<typename T>`告诉编译器，我下面要开始写模板函数,这个魔法效果只对下面紧挨着的第一个函数生效

下面是两种调用方式：

```cpp
void test01(){
    //1.自动类型推导
    inr a=10,b=20;
    cout<<a<<' '<<b<<endl;
    MySwap(a,b);
    cout<<a<<' '<<b<<endl;
    //2.手动指定类型
    MySwap<int>(a,b);
}
```

模板函数不允许发生自动类型转换，是强制类型函数  
普通函数就能够使用自动类型转换  
例如普通函数列表中的`int char` 可以接受`char int` ，也可以`int char`  

函数模板可以像普通函数一样被重载(不同参数个数)  
当普通函数和模板函数实现了重载时，编译器优先考虑普通函数，若类型完全匹配或转化后可以完全匹配
就调用普通函数，若类型与普通函数写的重载函数不能够匹配就调用模板函数

但当有调用模板函数的需求时，就在函数名后加上`<>`
(通过空模板实参列表的语法规定编译器只能通过模板匹配)`mm<>();`

### 模板函数实现过程

函数模板通过具体类型调用产生不同函数  

cpp->预编译器->index.i->  
(进行两次编译)
index.i->编译器->index.s（生成的汇编文件就变为具体函数了）  
index .s->汇编器->目标文件.obj(win).o(linux)  

链接器，将.o文件合并为可执行文件exe
>linux操作去复习一下

调用`my_add(int ,int)`的时候编译器就会生成一个具体的函数供调用  
变成汇编文件时，根据实际调用函数$n$的次数就变为$n$个函数  

## 单个模板类的基本语法

```cpp
template<class T>
class Person{
public:
    person(T id,T age){
        this->ID=id;
        this->AGE=age;
    }
    void show(){
        cout<<ID<<' '<<AGE；
    }
public:
    T ID;
    T AGE;
}
```

函数模板在调用时，可以自动类型推导  
类模板必须显示指定类型
`Person<int> p(10,20);`

## 函数模板实例

对char类型和int类型数组double进行排序

```cpp
#include<iostream>
using namespace std;

void print_array(int* array, int len) {
    for (int i = 0; i < len; i++) {
        cout << array[i] << ' ';
    }
}
template <class T>
void swap_two(T& a, T& b) {
    T median = b;
    b = a;
    a = median;
}
//每次进循环时flag为true，当最后一步执行true=false时，返回值为false，跳出循环
void bubble_sort(int* array, int len) {
    for (bool flag = false; flag = !flag; len--) {
        for (int i = 1; i <= len; i++) {
            if (array[i] > array[i - 1]) {
                swap_two(array[i], array[i - 1]);
                flag = false;
            }
        }
    }
}

int main() {
    int array[] = { 2,1,4,3 };
    int len = sizeof(array) / sizeof(int);
    print_array(array, len);
    bubble_sort(array, len);
    print_array(array, len);
    return 0;
}
```













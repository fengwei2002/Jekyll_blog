---
layout: post
title: 第一章：绪论下
tags: [数据结构]
date: 2020-02-11
---
运用工具分析DSA，去粗存精  

## 复杂度分析主要方法

迭代，级数求和  
递归，递归跟踪+递归方程  
猜测加验证  

### 级数

- 算数级数  
通项公式最高项  
- 幂方级数：比幂次高出一阶  

$$T_4(n)=1^4+2^4+...+n^4=O(n^5)$$  

- 几何级数
    $a^0+a^1+a^2+...+a^n=\frac{a^n+^1-1}{a-1}=O(a^n)$  

    1+2+4--->$O(2^n)$

- 收敛级数
    几何分布->$O(1)$
    调和级数->$O(log_n)$  
    $1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$
    对数级数$O(nlog_n)$  
    $log1+log2+log3+...logn=logn!$

>具体数学

```cpp
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        ..
    }
}
```

```cpp
for(int i=0;i<n;i++){
    for(int j=0;j<i;j++/j+=2020){
        ..
    }
}
```

$O(n^2)$：  
计算过程为
三角形面积和正方形面积复杂度都为$O(n^2)$  

### 冒泡排序

```cpp
void bubblesort(int A[];int n){
    for (bool sorted=false;sorted =!sorted;n--){
        for(int i=1;i<n;i++){//每一次把大的扔到最后面，全局有效标志翻转
            if(A[i-1]>A[i]){
                swap(A[i-1],A[i]);
                sorted=false;//清除全局有效标志
            }
        }
    }
}
```

经过k次扫描后，最大的k个元素就位(不变)  
单调，正确  

赤道周长的估算  
1天--25 x 4000 =$10^5$秒  
1世纪=$3$ x$10^4day$ = $3$ x $10^9sec$  

减少时间可以通过加强算法和更好的硬件

## 迭代与递归

递归的运行效率不一定高  
遇到大问题分而治之，不断减少问题规模

线性递归每个递归实例累计所需时间和为算法执行时间

递归跟踪：直观形象，适用于简单的递归模式
递推方程：适用于复杂的递归模式

### 数组倒置

```cpp
void reverse(int *A,int low,int high){
    if(low==high){
            return A[low];
    }
    int mi = (low+high)>>1;
    return sum(a,low,mi)+sum(a,mi+1,high);
}
```
递归版
迭代版
迭代精简版

![截图1](/public\image\数据结构绪论下01.jpg)

```cpp

```

### 数组求和

二分递归

```cpp

```

通过递归跟踪到递归基

T(n)=O(1) x (2^0+2^1+2^2...+2^long_n)
=o(n)

//几何级数，总合和和末项同阶

底层递归实例共n个，所以复杂度为O(n);

### Max2

从数组区间[lo,hi)中找出最大两个整数的比较次数，要求尽可能的少
hi并不是有效部分，但可以加进去考虑
![](/public\image\数据结构绪论下03.jpg);

```cpp
```

比较总数为(2n-3)

优化：

先构建两个指针，分别为第一个和第二个（先比较一次这两），
然后用第i个数据和她两作比较，如果大于x2则再与x1比较，这样只需要一次遍历便可找出来两个最大的值

![截图](/public\image\数据结构绪论下04.jpg)

```cpp

```

比较n-1次

### Max2:二分递归

左侧最大次大，
右侧最大次大；

四个元素比两次就行

![截图](/public\image\数据结构绪论下05.jpg)

```cpp

```

最好，最坏，
5n/3-2;







